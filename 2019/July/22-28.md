# 2019.7.22-2019.7.28

## 2019.7.22
请求顺序：
pwa
离线包
http cache

## 2019.7.24

# EPC

### 1、具有清晰的结构组织
1)用ID标识框架结构
2)书写代码要时刻有块状区域的归属感，不该省的HTML代码不必省
3)书写代码要有机械组装的感觉
4)书写有语义的HTML代码
### 2、可便捷的维护和搬移
1)代码的可复用性
2)CSS里的安全沙箱
### 3、健壮的浏览器兼容性
1）display:inline-block的元素，在ie7下设置text-indent无效
2）float元素设置与float同向的margin时，在ie7下margin值会多3像素
3）给float元素设置position:relative时，ie7下该元素在刚打开页面时会飘到页边上
4）设置了position:relative的元素，在父层出现滚动条时，ie7下会不随滚动条一起滚动
5）li列表在ie下会有可能出现li与li之间多3像素间隔
6）input type=“file”在ie下不能重置，textarea在ie下需要定义overflow:auto才不会一直出现滚动条
7）ie7下使用filter时，其中某个地方空格被去掉后会使该样式表失效
8）IE7、IE8不完全支持 !important 规则
9）IE7、IE8负边距会导致元素溢出 hasLayout 容器时显示异常
10）IE7、IE8中父元素带有 hasLayout 时，他的子元素设置的margin-bottom 值无效

# Generator 函数

Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）
``` 
function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }

```

执行它不会返回结果，返回的是指针对象

```
function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next(2) // { value: 2, done: true }
```
第二个 next 方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。

# async函数

async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已

### 优点
1、内置执行器
```
var asyncReadFile = async function (){
  var f1 = await readFile('/etc/fstab');
  var f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};

var result = asyncReadFile();
```
2、更好的语义

3、更广的适用性

4、返回值是 Promise

### 注意
最好把 await 命令放在 try...catch 代码块中。




## 2019.7.25

# PureComponent

只有PureComponent检测到`state`或者`props`发生变化时，PureComponent才会调用`render`方法。

`shadowEqual`只会"浅"检查组件的`props`和`state`，这就意味着嵌套对象和数组是不会被比较的。也就是说，如果这个组件还是纯组件(`PureComponent`)，那么深比较将会更浪费。

```
class MyComponent extends PureComponent {...}
```
使用PureComponent不仅能平滑过渡，甚至可以提升性能。

### 注意
在纯组件有子组件的时候，所有基于this.context改变的子组件，在this.context改变时， 将不会重新渲染，除非在父组件(Parent ParentComponent)中声明contextTypes。

只要你遵循下列两个简单的规则就可以安全的使用PureComponent来代替Component:

- 虽然通常情况下易变性就是不好的，但是当使用`PureComponent`时问题会变得复杂。
- 如果你在`render`方法中创建一个新的函数，对象或者是数组那么你的做法（可能）是错误的。


## 2019.7.26