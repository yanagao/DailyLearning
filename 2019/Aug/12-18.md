# 2019.8.12-2019.8.18

## 2019.8.12

# Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.

## 2019.8.13
# serverless
## Backends For Frontends(BFF)
服务自治，谁使用谁开发
1、场景化
2、轻流程化
3、Serverless化：利用云平台实现资源的按需分配和弹性伸缩，减少资源浪费
4、自动化运维：Devops——>noops

## 2019.8.14
# 直出踩坑
上面组件如果渲染失败会传到下面组件中，因此需要每个组件都包裹个<div>不然会渲染不出来

## 2019.8.15
# 时间复杂度算法
一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)

算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

O(2n2+n +1) = O (3n2+n+3) = O (7n2 + n) = O ( n2 ) 

若算法中语句执行次数为一个常数，则时间复杂度为O(1)

## 2019.8.18
接上条

常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

求解算法的时间复杂度的具体步骤是：
- 找出算法中的基本语句：算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。
- 计算基本语句的执行次数的数量级
- 用大Ο记号表示算法的时间性能

```
for (i=1; i<=n; i++)
    x++;
for (i=1; i<=n; i++)
    for (j=1; j<=n; j++)
        x++;
```

则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。

#### 求和法则
是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))

#### 乘法法则
是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n))